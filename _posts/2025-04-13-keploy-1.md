---
layout: post
title: E2E 테스트를 위한 Keploy 검토
subtitle: 테스트 자동화
excerpt_image: https://raw.githubusercontent.com/lkhlkh23/lkhlkh23.github.io/master/images/2025-04-13/banner.png
categories: java
tags: [java, Spring, test, keploy]
---
인류는 농업혁명 → 산업혁명 → AI 혁명 으로 발전을 하고 있다. 현재 조직에서 수행하는 테스트 같은 경우 수동으로 테스트를 직접 수행하고 테스트 결과를 만든다. 현재 조직은 낫과 호미를 들고 농사를 짓는 농경사회이다. 그렇기 때문에 자동화를 통한 산업혁명을 일으킬려고 한다. 아직 우리에게 AI 를 통한 AI 혁명은 이르다.

![0.png](https://raw.githubusercontent.com/lkhlkh23/lkhlkh23.github.io/master/images/2025-04-13/0.png)

### What is E2E Test ..?!

E2E 테스트는 사용자가 애플리케이션을 실제로 사용하는 것처럼 전체 흐름을 테스트하는 방식을 의미한다. 실제 운영환경과 유사하게 동작을 확인하기 때문에 전체 시스템을 통합적으로 테스트한다.

### What is Keploy ..?!

Keploy 는 API 테스트 케이스와 mock / stub 데이터를 자동으로 생성해주는 오픈소스 테스트 도구로 코드 변경 없이 네트워크 트래픽을 기록하고 재현하여 테스트를 수행한다.

- **Record Mode**
  - 애플리케이션을 실행하면서 API 호출, DB 쿼리, 외부 API 호출 등의 네트워크 트래픽을 기록
  - 이 기록은 테스트 케이스와 mock 데이터로 저장
- **Test Mode**
  - 애플리케이션의 새 버전을 테스트할 때, 이전 기록을 재생하고, 실제 응답과 비교하여 테스트 결과 생성
  - 별도의 테스트 환경 구성 불필요

### What is features of Keploy

- CI/CD 통합 지원
  - JUnit, go-test, jest 등과 통합 가능. Jenkins 등에서 사용 가능
- 복잡한 API 흐름 테스트 가능
  - 다양한 툴(Postman, curl 등)로 호출된 복잡한 플로우도 기록하고 재생 가능
- EBPF 기반 코드리스 통합
  - eBPF 기술을 사용해 코드 변경 없이 네트워크 계층에서 자동으로 테스트 가능
- Mock 재사용 가능
  - DB, 외부 API 등 의존성을 mock으로 자동 대체하고, 재사용 가능
- 노이즈 필터링
  - 테스트 시 랜덤값, 타임스탬프 등 불필요한 변경 요소를 자동 감지하고 무시

### How to work Keyploy ..?!

![1.png](https://raw.githubusercontent.com/lkhlkh23/lkhlkh23.github.io/master/images/2025-04-13/1.png)

eBPF 는 리눅스 커널의 기능으로, 애플리케이션의 동작을 커널 레벨에서 제어할 수 있다. 네트워크 패킷 분석 및 AP요청/응답을 가로채는 작업을 수행할 수 있다. Keploy 는 eBPF Hooks 를 이용해서 API 에 인터셉터와 필터를 구현하지 않고, API 로 유입되는 요청과 응답, 외부 네트워크 (Database, 외부 API) 에 의한 요청과 응답들을 모두 처리할 수 있다.

결국은, 요청/응답을 기록하고 **mock 처리를 수행**한다. 가독성을 높이기 위해, Keploy는 네트워크에서 발생하는 **바이너리 데이터 → YAML 형식으로 변환**하여 저장한다. 이로 인해 생성된 테스트 코드와 mock 데이터는 개발자가 직접 확인하고 수정이 편하다.

### Why is Keploy well-suited for integration testing ..?!

**실제 요청/응답 기반 자동 테스트 케이스 생성**

Keploy 는 운영 중인 API 에 대한 **실제 사용자 요청/응답**을 캡처해서 저장한다. 그렇기 때문에 개발자가 테스트 케이스를 작성하지 않아도 된다. 테스트 시 같은 요청을 다시 보내고, 응답을 비교하여 리그레션(regression) 테스트를 자동 수행한다.

**모든 외부 의존성을 자동으로 Mock 처리**

Keploy 는 DB, 3rd Party API 를 포함한 모든 외부 의존성에 대한 호출을 캡처하고 모킹한다. 외부 환경없이 안정적으로 테스트 수행이 가능하다.

**CI/CD 통합성**

CLI 를 제공하기 때문에 Jenkins 와 같은 CI/CD 도구와 쉽게 통합이 가능하다.

## How to use Keploy ..?!

Keploy 는 linux 에서만 지원하기 때문에 Mac 에서 테스트하기 위해서는 도커를 이용해야한다.

**Keploy 도커 이미지 생성**

```bash
# Keploy 도커 이미지 생성
docker pull ghcr.io/keploy/keploy:latest
docker tag ghcr.io/keploy/keploy:latest keploy
```

**API 도커 이미지 생성**

```bash
# Dockerfile 생성
# OpenJDK 21 사용
FROM eclipse-temurin:21-jdk

# 앱 파일이 들어갈 작업 디렉토리 설정
WORKDIR /app

# 빌드된 JAR 파일을 Docker 컨테이너로 복사
COPY build/libs/coupon-0.0.1-SNAPSHOT.jar app.jar

# 외부에서 접근할 수 있도록 포트 열기
EXPOSE 8080

# 애플리케이션 실행 명령
ENTRYPOINT ["java", "-jar", "app.jar"]
```

```bash
docker build -t coupon-app .
```

**Keploy 레코드 & API 실행**

```bash
keploy record -c "docker run -p 8081:8081 --name coupon-app --network keploy-network coupon-app" --container-name "coupon-app" --buildDelay 60
```

- keploy record -c
  - 레코드 시작할 때, 실행할 명령어
- "docker run -p 8081:8081 --name coupon-app --network keploy-network coupon-app"
  - coupon-app 컨테이너 실행
  - keploy-network 라는 도커 네트워크 컨테이너 연결 (keploy 가 사용하는 네트워크)
- --buildDelay 60
  - 컨테이너가 실행되고 나서, 60초 동안 대기 후 기록을 시작

명령어를 수행하고 API 를 호출하면 API 호출을 캡처한 yaml 파일과 Mock 결과 yaml 파일을 생성한다.

**Keploy 테스트**

```bash
keploy test -c "docker run -p 8081:8081 --name coupon-app --network keploy-network coupon-app" --container-name "coupon-app" --buildDelay 60
```

명령어를 수행하면 생성된 yaml 을 기준으로 아래와 같은 레포트 결과를 생성한다.

```yaml
# Generated by Keploy (2.4.18)
version: api.keploy.io/v1beta1
kind: Http
name: test-1
spec:
    metadata: {}
    req:
        method: GET
        proto_major: 1
        proto_minor: 1
        url: http://localhost:8081/coupons/3
        header:
            Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
            Accept-Encoding: gzip, deflate, br, zstd
            Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
            Cache-Control: max-age=0
            Connection: keep-alive
            Cookie: jenkins-timestamper-offset=-32400000; Idea-f36250f2=d7691406-5065-4a28-9b80-870515a93e02
            Host: localhost:8081
            Sec-Ch-Ua: '"Google Chrome";v="135", "Not-A.Brand";v="8", "Chromium";v="135"'
            Sec-Ch-Ua-Mobile: ?0
            Sec-Ch-Ua-Platform: '"macOS"'
            Sec-Fetch-Dest: document
            Sec-Fetch-Mode: navigate
            Sec-Fetch-Site: none
            Sec-Fetch-User: ?1
            Upgrade-Insecure-Requests: "1"
            User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36
        body: ""
        timestamp: 2025-04-13T08:28:44.440457169Z
    resp:
        status_code: 200
        header:
            Connection: keep-alive
            Content-Length: "8"
            Content-Type: text/html;charset=UTF-8
            Date: Sun, 13 Apr 2025 08:28:44 GMT
            Keep-Alive: timeout=60
        body: coupon-3
        status_message: OK
        proto_major: 0
        proto_minor: 0
        timestamp: 2025-04-13T08:28:46.515555753Z
    objects: []
    assertions:
        noise:
            header.Date: []
    created: 1744532926
curl: |
    curl --request GET \
      --url http://localhost:8081/coupons/3 \
      --header 'Accept-Encoding: gzip, deflate, br, zstd' \
      --header 'Host: localhost:8081' \
      --header 'Sec-Fetch-Site: none' \
      --header 'Sec-Ch-Ua: "Google Chrome";v="135", "Not-A.Brand";v="8", "Chromium";v="135"' \
      --header 'Sec-Fetch-Dest: document' \
      --header 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36' \
      --header 'Sec-Ch-Ua-Platform: "macOS"' \
      --header 'Cookie: jenkins-timestamper-offset=-32400000; Idea-f36250f2=d7691406-5065-4a28-9b80-870515a93e02' \
      --header 'Cache-Control: max-age=0' \
      --header 'Sec-Fetch-Mode: navigate' \
      --header 'Connection: keep-alive' \
      --header 'Sec-Ch-Ua-Mobile: ?0' \
      --header 'Upgrade-Insecure-Requests: 1' \
      --header 'Sec-Fetch-User: ?1' \
      --header 'Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7' \
      --header 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7' \
respType: json

```

![2.png](https://raw.githubusercontent.com/lkhlkh23/lkhlkh23.github.io/master/images/2025-04-13/2.png)

### What is the plan for using Keploy ..?!

Keploy 를 이용하여 **`리팩토링 후 개발자 테스트의 자동화`**를 구축할 예정이다. 현재 재직 중인 회사에서는 서비스 배포를 위해 QA 부서의 검증이 필수적이며, 개발자 테스트가 먼저 진행되어야 한다. 시스템의 안전성을 확보하기 위해 리팩토링 단위는 작게 진행될 것이며, 이로 인해 반복적인 개발자 테스트가 발생할 것이다. 이러한 반복적인 개발자 테스트를 Keploy 로 대체할 계획이다.

절차는 다음과 같다. 먼저, Jenkins 에서 Keploy Record Job 을 실행하여 테스트 파일 (yaml) 을 미리 생성한다. 이후 개발자 테스트가 필요할 때마다 Jenkins 에서 Keploy Test Job 을 실행하고, 수행된 테스트 결과는 자동으로 Teams 채널에 레포트로 공유될 수 있도록 설정할 예정이다.

포스팅을 보면서 … 이 방법이 정말 효과적일까?! 라는 의구심을 가지는 사람들이 많을 것이다. 아닐 수 있다! 하지만 이런 시도를 통해 점진적으로 테스트를 하는 방법을 발전시키면된다. 처음부터 완벽한 아이디어를 내는 건 어렵다. 비판보다는 함께 고민하고 더 나은 방향으로 발전시켰으면 좋겠다. 완성된 결과물은 처음부터 완벽해서가 아니라, 많은 사람의 생각과 수정을 거쳐 완성되는 것이다. 머리와 손을 사용하지 않고, 입으로만 비판을 하는 사람이 있다면

### And I am …

현재 재직중인 조직에서는 BackEnd 개발자에 대한 평가가 아래와 같은 이유로 인해 좋지 않다고 생각한다.

- 비시각적인 개발 결과물
- 제한적인 정량적 지표
- 비용절감 한계 (평가의 Key)

그렇기 때문에 BackEnd 개발자는 조직에서 수행하고 있는 개발업무 외 새로운 결과물을 늘 요구받는다. 새로운 결과물에 대한 명확한 방향성과 요구사항이 정리되있다면 어렵지 않을 것이다. 하지만, 그런것이 없다.



![3.png](https://raw.githubusercontent.com/lkhlkh23/lkhlkh23.github.io/master/images/2025-04-13/3.png)

그래서 항상 이런 고민을 반복하고, 해답을 찾기 위해 여러 가지를 시도한다. 그 과정에서 얻는 인사이트도 분명 있지만, 들인 시간에 비해 돌아오는 결과는 크지 않았다. 지금 내가 진짜 집중해야 할 것은 이런 방향이 아닐지도 모른다는 생각이 든다. 그럴 때마다 여러 가지 생각이 머릿속을 맴돈다.
